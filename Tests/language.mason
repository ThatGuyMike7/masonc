/*
square :: (n: s64);

main :: ()
{
	num := 12;
	printf("Square of " + num + " is " + square(num));
}

square :: (n: s64) -> s64
{
	return n * n; 
}
*/

/*
proc square(n: s64);

proc main()
{
	num := 12;
	printf("Square of " + num + " is " + square(num));
}

proc square(n: s64) -> s64
{
	return n * n;
}
*/

module Mason_Test;

import cstdlib;

// Define a procedure
proc square(x: s32) -> s32
{
	return x * x;
}

// Define a type
struct Data
{
	x: f32;
	n: s32;
	
	resource: ^s32;
}

// Define a method
proc(Foo) calc() -> f32
{
	return x * this.n;
}

// Define a constructor
proc new_Data() -> Data
{
	return Data { 0.0, 0, cstdlib::malloc(size_of(s32)) };
}

// Define a destructor
proc free_Data(data: ^Data)
{
	cstdlib::free(data);
}

// Define a copy constructor
proc copy_Data(data: ^Data) -> Data
{
	copy: Data;
	copy.x = data.x;
	copy.n = data.n;
	cstdlib::memcpy(copy.resource, data.resource, size_of(@data.resource));
	return copy;
}

proc main()
{
	// Calculate square of a number
	num := square(5);	
	if(num == 25)
		cstdlib::printf("square yes\n");
	
	// Get the address of the number
	num_ptr: ^s32 = ^num;
	cstdlib::printf("Address: " + num_ptr + " Value: " + @num_ptr + "\n");
	
	// Print numbers 1 to 10
	for(i: u64 = 1; i <= 10; i += 1)
	{
		cstdlib::printf(i);
	}
	cstdlib::printf("\n");

	// Call our method on an instance of our type
	data := Data { x = 2.5, n = 4 };
//	data := Data { 2.5, 4 };
//	data: Data = { x = 2.5, n = 4 };
//	data: Data = { 2.5, 4 };
	result := data.calc();
	cstdlib::printf(result + "\n");
	
	// Create an instance of our type with a constructing procedure
	data2: Data = new_Data();
	cstdlib::printf(@data2.resource);
	
	// Defer destruction of our type until the end of this procedure
	defer free_Data(data2);
}
