
// variable_declaration := name ":" type
//
// This language features a strong type system so that there are no implicit casts or conversions,
// thus every variable must be declared with a type.
// Please view document 3 for a list of built-in types.
index: u64;

// 1.
// Unassigned variables are not default-initialized.
x: s64;

// Compile error because "x" was never initialized.
y: s64 = x + 1;
// In more complicated programs, the compiler may not be able to detect this statically
// and it will instead be detected at runtime in the Debug configuration.

// 2.
// Integer types can represent characters.
letter: u8 = "A";       // = 65 in the ASCII table
letter2: byte = "B";    // = 66 in the ASCII table

// 3.
// Why is there no specific character type but a distinction between "u8" and "byte"?
//
// It is true that the types "u8" and "byte" are equivalent,
// unlike "bool" which has the same size but different valid values:

// Valid.
a1: bool = true;
b1: byte = 0;

// Compile error, there is no implicit conversion.
a2: bool = 0;
b2: byte = true;

// However, the distinction between "u8" and "byte" allows for hinting at the semantics of your code,
// while a character type is often semantically used as a character, number or byte in other
// programming languages.
//
// Restricting a character type to only allow assignment of character literals and otherwise require
// an explicit cast has been considered, but when dealing with characters, it is common to inspect
// the numeric representation, for example to check if an ASCII character is alphabetic.
//
// Depending on the encoding, unicode code points may require a larger size than a byte too,
// and a single code point may or may not represent a single character in a string of text.
//
// Because text is a complicated problem, it was decided not to add a specific character type.

// 4.
// In many cases the type can be inferred by the compiler.

// Default integer type "s64"
a := 3;

// Default unsigned integer type "u64"
b := 100u;

// Default floating point type "f64"
c: = 0.0;

// Floating point type "f32"
d: = 0.0f;

// 5.
// Here is a table of all existing literal types:
a := "z";               // byte
b := "Hello World";     // ^byte

c := true;              // bool
d := false;             // bool

e := 50u;               // u64
f := -61;               // s64

g := 3.14159265f;       // f32
h := 99.98;             // f64

// 6.
// The language encourages good practise by generating warnings when unsigned numeric literals are
// not designated with the "u" suffix or literals of type "f32" with the "f" suffix in places where
// the type of the target variable is not immediately clear from the call-site.
// All style and guideline warnings can optionally be turned off.
proc foo(n: u64);

struct moo
{
    num: u8;
}

// Warning, did not use the "u" suffix which may help readability here.
foo(5);

// Warning, did not use the "u" suffix which may help readability here.
instance: moo = { 10 };

// 7.
// Type specifiers can change the semantics of a variable.
// The "mut" specifier allows the variable to be mutated at runtime.
i: mut u64 = 0;

// This works.
i += 1;

j: u64 = 0;

// Compile error, "j" is immutable.
j += 1;

// The "const" specifier means the variable is a compile-time constant and
// cannot be mutated at runtime.
const x: u8 = 0;

// Compile error, "x" is a constant.
x = 15;