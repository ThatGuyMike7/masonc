// A common practise in programming is passing or returning values that represent
// an invalid state when either an error occured, something could not be found, and so on.
//
// You could return a null pointer in a search procedure if an element
// could not be found in a container, but null pointers lead to problems.
//
// Whenever you are dealing with a pointer - unless otherwise documented - you have to assume
// that it can be a null pointer. You have to look up the procedure and hope that someone
// documented that a null-check is required. To avoid this problem, some languages introduce
// a "reference" type which can never be null, but at the same time must always be initialized.
//
// This language solves the problem with the "nullable" type, which does not
// have to be immediately initialized and can represent either a valid or invalid value.
// Some languages refer to this as "optional" types.
// The value will not be constructed until you need it to.

// 1.
// The syntax of a nullable type is simple and clear.
proc foo(number: ?s64)
{
    // Does the nullable contain a value?
    // If yes, then it is safe to use the value.
    if(number?)
    {
        if(number == 0)
        {
            // ...
        }
    }
}

// 2.
// Nullables are a great way to communicate if a procedure can fail.
proc read_file(handle: file_handle) -> string?
{
    // ...

    if(file_exists_and_could_be_read)
    {
        return contents;
    }
    else
    {
        // The "null" keyword is only used in conjunction with nullable types and
        // designates that the nullable's value is not available.
        return null;
    }
}

proc main()
{
    result := read_file("hello.txt");

    // Equivalent to "result?"
    if(result != null)
    {
        // ...
    }
}

// 3.
// Nullable pointers.
proc foo(data: ?s64)
{

}